!============================================================================================!
! QD2D.f90: THIS PROGRAM PERFORMS THE 2D QUANTUM DYNAMICS ON METASTABLE STATE
! AND PRODUCES CROSS-SECTION, NORM PROFILES LIKE VARIABLES.
! EXTERNAL FILES CONTAINING SORTED DATA OF POTENTIAL ENERGIES ALONG X-Y 2D GRID ARE REQUIRED.
! THIS IS A COMMON PROGRAM AND, DEPENDING ON THE INPUT 'SORTED DATA' FILES AND THE PARAMETERS
! DEFINED IN THE 'CONST.f90' FILE, DIFFERENT SYSTEM CAN BE INVESTIGATED VIA 2D DYNAMICS.
!============================================================================================
! PROGRAM WP_DYNAMICS: MAIN PROGRAM (PARALLELIZED BY OPENMP)
! DEPENDS ON A BUNCH OF SUBROUTINES(EXTERNAL, INTERNAL) AND FUNCTIONS.
!
! RUN THIS CODE WITH THE FOLLOWING EXTERNAL CODES.
!    src/MACHINARY.f90 :: INCLUDES: XINTGR1D, XINTEGRATE2D, FFT2D |SUBROUTINES AND FUNCTIONS.
!                   NEEDED FOR 1D, 2D INTEGRATION AND COMPLEX FFT.
!                   SEE THE SCRIPT ITSELF FOR MORE DETAILS.
!    src/VARIABLE.f90 :: A SUBROUTINE THAT INCLUDES ALL THE VARIABLES (e.g. PHASE GRID,
!                  MOMENTUM GRID AND OTHER VARIABLES, NO NEED TO MODIFY THIS CODE.
!                  GIVES YOU BACK ALL THE 2D, 1D ARRAYS.)
!    src/CONST.f90  :: A TYPICAL FORTRAN MODULE WHICH INCLUDES ALL NECESSARY CONSTANTS FOR
!                THE SIMULATION AS WELL AS THE PARAMETERS TO CREATE THE GRID (e.g.
!                MIN OF GRID, MAX OF GRID, TIME OF SIMULATION. etc.)
!    libs/fftpack5.1.f :: THE 'CORE' SUBROUTINE NEEDED FOR FOURIER(COMPLEX) TRANSFORM.
!                    THE FFT2D SUBROUTINE IN MACHINARY.f USES IT.
!                    CHECK THE LIBRARY: https://www.netlib.org/fftpack/ 
!    Reference:
!     P.N. Swarztrauber, Vectorizing the FFTs, in Parallel Computations (G. Rodrigue, ed.),
!     Academic Press, 1982, pp. 51--83.
!    Developer
!     Paul N. Swarztrauber, National Center for Atmospheric Research, Boulder, CO
!
!
!    libs/INTEGRATE.f  :: THE 'CORE' SUBROUTINE FOR INTEGARTION
!                                (MAINLY TRAPEZOIDAL RULE)
!                                USED BY SUBROUTINE: XINTGR1D, FUNCTION: XINTEGRATE2D
!                                CHECK OUT: https://www.tifr.res.in/~antia/nmse3.html
!     Cite as: NUMERICAL METHODS FOR SCIENTISTS AND ENGINEERS, THIRD EDITION by H. M. ANTIA
!           Theoretical Astrophysics Group, Tata Institute of Fundamental Research, Mumbai, India
!           Published by Hindustan Book Agency, New Delhi 110016, India
!
!
!BEFORE RUNNING THE PROGRAM, CHECK THE "CAP_FUNC" AND CHANGE THE CAP-BARRIER
! STARTING POINT(S)
!
!CAUTION: SINCE THIS IS FORTRAN LANGUAGE, IF YOU FACE SEGMENTATION FAULT/ SIEGSEV ERROR
!WHILE USING EXCESSIVE GRID ARRAYS WHICH NEED HUGE RAM MEMORY TO ALLOCATE THOSE, PLEASE
!CONSIDER USING DYNAMIC ARRAYS FOR THE LARGE SUBROUTINES USED IN THIS MAIN CODE. THIS
!DYNAMIC ALLOCATION OF MEMORY WILL UNFORTUNATELY CALL FOR MORE EXECUTION TIME.

!Soubhik M., K.Bravaya, Boston University, Oct.2021
!===========================================================================================

PROGRAM WP_DYNAMICS
USE CONST
USE OMP_LIB
IMPLICIT REAL*8(A-H,O-Z)
EXTERNAL :: XINTGR1D
DIMENSION RAW_EKIN(NEKIN)
DIMENSION SIGMA_ARR_C(NEKIN)
DIMENSION XNORM_D_KE_C(NEKIN, NSTEPS)
DIMENSION XNORM_F_KE_C(NEKIN, NSTEPS)
DIMENSION XNORM_CAP_KE_C(NEKIN, NSTEPS)

REAL(8), ALLOCATABLE :: SIGMA_ARR(:)
REAL(8), ALLOCATABLE :: XNORM_D_KE(:, :), XNORM_F_KE(:, :)
REAL(8), ALLOCATABLE :: XNORM_CAP_KE(:, :)
REAL(8), ALLOCATABLE :: XNORM_D(:), XNORM_F(:)
REAL(8), ALLOCATABLE :: XNORM_CAP(:)
CHARACTER(LEN=100) :: FNAME1, FNAME2, CHARAC

!START OF THE TIME-COUNT!
T1 = OMP_GET_WTIME()

!KINETIC ENERGY ARRAY, EMIN AND EMAX ARE PREDEFINED
dE=(EMAX-EMIN)/(DFLOAT(NEKIN-1))
DO I = 1, NEKIN,1
    RAW_EKIN(I)= EMIN+dE*(I-1)
ENDDO
!
!
!SOME PRINTS ON SCREEN
PRINT*, ''
PRINT*, 'NO OF PROCS. AVAILABLE:',OMP_GET_NUM_PROCS()
PRINT*, 'NO OF MAX. THREADS POSSSIBLE:',OMP_GET_MAX_THREADS()

PRINT*, ''
PRINT*, 'GRID LENGTH IN X AND Y:', L, M
PRINT*, 'TIME OF DYANMICS (fs)', NINT(T_MAX)
PRINT*, 'TIME STEPS:', NSTEPS
PRINT*, 'TOTAL EKIN SAMPLE TO RUN:', NEKIN
PRINT*, 'dT IN fs:', dT*AU2FS
PRINT*, ''

!OMP PARALLEL RUN STARTS HERE
!$OMP PARALLEL PRIVATE(SIGMA, SIGMA_ARR, EKIN, XNORM_D_KE, XNORM_F_KE, &
!$OMP XNORM_CAP_KE, XNORM_D, XNORM_F, XNORM_CAP) &
!$OMP SHARED(SIGMA_ARR_C, XNORM_D_KE_C, XNORM_F_KE_C, XNORM_CAP_KE_C, RAW_EKIN)

SIGMA_ARR_C = 0.00D0
XNORM_D_KE_C = 0.00D0
XNORM_F_KE_C = 0.00D0
XNORM_CAP_KE_C = 0.00D0

ALLOCATE(XNORM_D_KE(NEKIN,NSTEPS))
ALLOCATE(XNORM_F_KE(NEKIN,NSTEPS))
ALLOCATE(XNORM_CAP_KE(NEKIN,NSTEPS))
ALLOCATE(SIGMA_ARR(NEKIN))

XNORM_D_KE = 0.00D0
XNORM_F_KE = 0.00D0
XNORM_CAP_KE = 0.00D0
SIGMA_ARR = 0.00D0

!$OMP DO
DO I=1, NEKIN,1
EKIN = RAW_EKIN(I)

ALLOCATE(XNORM_D(NSTEPS))
ALLOCATE(XNORM_F(NSTEPS))
ALLOCATE(XNORM_CAP(NSTEPS))

CALL GEN_SIGMA(I, EKIN, XNORM_D, XNORM_F, XNORM_CAP, SIGMA)
SIGMA_ARR(I) = SIGMA_ARR(I)+SIGMA
PRINT*, "SAMPLE NO", I, EKIN, SIGMA


XNORM_D_KE(I, :) = XNORM_D
XNORM_F_KE(I, :) = XNORM_F
XNORM_CAP_KE(I, :) = XNORM_CAP

DEALLOCATE(XNORM_D)
DEALLOCATE(XNORM_F)
DEALLOCATE(XNORM_CAP)

ENDDO

!$OMP END DO

!$OMP BARRIER

!$OMP CRITICAL
  SIGMA_ARR_C = SIGMA_ARR_C+SIGMA_ARR
  XNORM_D_KE_C = XNORM_D_KE_C + XNORM_D_KE
  XNORM_F_KE_C = XNORM_F_KE_C + XNORM_F_KE
  XNORM_CAP_KE_C = XNORM_CAP_KE_C + XNORM_CAP_KE

DEALLOCATE(XNORM_D_KE)
DEALLOCATE(XNORM_F_KE)
DEALLOCATE(XNORM_CAP_KE)
DEALLOCATE(SIGMA_ARR)

!$OMP END CRITICAL

!$OMP END PARALLEL

!END OF PARALLEL RUN

!PRINT OUT FORMATTING OF THE OUTPUT FILE
!FILENAME CREATIONS, NAMED BY T_MAX VARIABLE

94    FORMAT (F14.6, 5X, F16.13, 5X, F16.13, 5X, F20.18)

WRITE(CHARAC, *)INT(T_MAX)
FNAME1 = 'data/outputs/NORM_PROFILE_MODEL_MORSE_'//TRIM(ADJUSTL(CHARAC))//'fs'!//'_NOCAP'

WRITE(CHARAC, *)INT(T_MAX)
FNAME2 = 'data/outputs/EKIN_DISTR_MODEL_MORSE_'//TRIM(ADJUSTL(CHARAC))//'fs'!//'_NOCAP'

!
OPEN(UNIT=22, FILE=FNAME1, ACTION='WRITE')
OPEN(UNIT=23, FILE=FNAME2, ACTION='WRITE')
!
!
WRITE(23,*) ACHAR(9), "#Electron energy (eV)", ACHAR(9), "cross-section (a.u.)"

DO I = 1, NEKIN,1
    WRITE(23, *) RAW_EKIN(I),SIGMA_ARR_C(I)
ENDDO


WRITE(22,*) ACHAR(9), "#Time (fs)", ACHAR(9),"Norm in V_d",ACHAR(9),"Norm in V_f",ACHAR(9),"Norm through CAP"

DO I = 1, NSTEPS, 1

    CALL XINTGR1D(RAW_EKIN, XNORM_F_KE_C(:, I),  'TR', NEKIN, XFVAL)
     
    CALL XINTGR1D(RAW_EKIN, XNORM_CAP_KE_C(:, I), 'TR', NEKIN, XCAPVAL)

    WRITE(22, 94) ANINT(0.0D0+DFLOAT((I-1))*dT*AU2FS), XNORM_D_KE_C(1, I), XFVAL, XCAPVAL

ENDDO


T2 = OMP_GET_WTIME()
!END OF THE TIME-COUNT!

PRINT*, 'TIME_ELAPSED', T2-T1, 'S'


END PROGRAM WP_DYNAMICS

!====================================================================================
!SUBROUTINE GEN_SIGMA: GENERATES SIGMA i.e. CROSS-SECTION AND OTHER RELEVANT COMPO-
!NENTS DEPENDING ONE THE DEMAND. 
!CAUTION: BE CAREFUL WITH VARIABLE DECLARATION.
!IF YOU FACE ANY FORTRAN 'SEGMENT/SIEGSEV' ERROR, USE MORE DYNAMIC ARRAYS TO DEFINE  
!THE PLETHORA OF 2D ARRAYS DEFINED IN THE PREAMBLE(S) OF THE SUBROUTINE(S).
!NEEDS 'VARIABLE' SUBROUTINE DEFINED IN 'VARIABLE.f' SUBROUTINE(EXTERNAL)
!
!TO FEED POTENTIALS IN THE SUBROUTINE AS INPUTS (GIVEN AS SORTED GRIDDATA), 
!PLEASE CREATE A FILE WITH THE FOLLOWING ORDER OF COLUMNS: 
!METASTABLE STATE POTENTIAL, FINAL STATE POTENTIAL, IMAGINARY POTENTIAL, INITIAL
!STATE WAVE PACKET (YOU HAVE TO GENERATE EXTERNALLY). REPLACE THE FILE NAME PER NEED
!IN THE FOLLOWING 'CHARAC' VARIABLE IN THE SUBROUTINE. 
!====================================================================================

SUBROUTINE GEN_SIGMA(INUM, EKIN, XNORM_D, XNORM_F, XNORM_CAP, SIGMA)
USE CONST
IMPLICIT REAL*8(A-H,O-Z)
INTERFACE
   FUNCTION COUPLING_W(XMESH, YMESH) RESULT(Z)
   USE CONST
   REAL*8,INTENT(IN) :: XMESH, YMESH
   REAL*8 :: Z
   DIMENSION XMESH(L, M), YMESH(L, M), Z(L, M)
   END FUNCTION COUPLING_W
 
   FUNCTION POTENTIAL_D(XMESH, YMESH) RESULT(Z)
   USE CONST
   REAL*8,INTENT(IN) :: XMESH, YMESH
   REAL*8 :: Z
   DIMENSION XMESH(L, M), YMESH(L, M), Z(L, M)
   END FUNCTION POTENTIAL_D

   FUNCTION POTENTIAL_F(XMESH, YMESH) RESULT(Z)
   USE CONST
   REAL*8,INTENT(IN) :: XMESH, YMESH
   REAL*8 :: Z
   DIMENSION XMESH(L, M), YMESH(L, M), Z(L, M)
   END FUNCTION POTENTIAL_F
 
   FUNCTION PSI_D0(XMESH, YMESH) RESULT(Z)
   USE CONST
   REAL*8,INTENT(IN) :: XMESH, YMESH
   REAL*8 :: Z
   DIMENSION XMESH(L, M), YMESH(L, M), Z(L, M)
   END FUNCTION PSI_D0

END INTERFACE
EXTERNAL :: CAP_FUNC, WF_NORM, XINTEGRATE2D

INTEGER, INTENT(IN) :: INUM
REAL(8), INTENT(IN) :: EKIN
REAL(8), INTENT(OUT) :: SIGMA
REAL(8), INTENT(OUT) :: XNORM_D, XNORM_F, XNORM_CAP

DIMENSION XNORM_F(NSTEPS), XNORM_D(NSTEPS)
DIMENSION XNORM_CAP(NSTEPS)

COMPLEX, ALLOCATABLE :: V_D(:, :), V_F(:, :)
REAL(8), ALLOCATABLE :: GAMMA_FUNC(:, :)
REAL(8), ALLOCATABLE :: V_D_REAL(:, :), V_F_REAL(:, :), PSI_READ(:, :)
COMPLEX, ALLOCATABLE :: PSI_D0_EXT(:, :)
COMPLEX, ALLOCATABLE :: FACT1(:, :), FACT2(:, :)
REAL(8), ALLOCATABLE :: X(:), Y(:)
REAL(8), ALLOCATABLE :: XMESH(:, :), YMESH(:, :)
REAL(8), ALLOCATABLE :: P_XMESH(:, :), P_YMESH(:, :)
INTEGER, ALLOCATABLE :: NXMESH(:, :), NYMESH(:, :)
REAL(8), ALLOCATABLE :: C_CAP(:, :)
REAL(8), ALLOCATABLE :: TIME_ARRAY(:)
REAL(8), ALLOCATABLE :: FLUX(:)



COMPLEX, ALLOCATABLE :: PSI_XF(:, :), PSI_XD(:, :)
COMPLEX, ALLOCATABLE :: PSI_KF(:, :), PSI_KD(:, :)

REAL(8), ALLOCATABLE :: CAP_VFUNC(:, :)
COMPLEX, ALLOCATABLE :: V11(:, :), V12(:, :), T_KE(:, :)
COMPLEX, ALLOCATABLE :: V21(:, :), V22(:, :)
COMPLEX, ALLOCATABLE :: V_DIAG(:, :), V_F_AUG(:, :)
COMPLEX, ALLOCATABLE :: PSI_MOD_XD(:, :)
COMPLEX, ALLOCATABLE :: PSI_MOD_XF(:, :)
COMPLEX, ALLOCATABLE :: CP_PSIXD(:, :)
CHARACTER(LEN=70) :: CHARAC

ALLOCATE (X(L))
ALLOCATE (Y(M))
ALLOCATE (XMESH(L, M))
ALLOCATE (YMESH(L, M))
ALLOCATE (P_XMESH(L, M))
ALLOCATE (P_YMESH(L, M))
ALLOCATE (NXMESH(L, M))
ALLOCATE (NYMESH(L, M))
ALLOCATE (C_CAP(L, M))
ALLOCATE (V_D(L, M))
ALLOCATE (V_D_REAL(L, M))
ALLOCATE (V_F_REAL(L, M))
ALLOCATE (PSI_READ(L, M))
ALLOCATE (V_F(L, M))
ALLOCATE (GAMMA_FUNC(L, M))
ALLOCATE (PSI_D0_EXT(L, M))
!========================!
!CALL FOR VARIABLES.     !
!========================!

CALL VARIABLE (X, Y, XMESH, YMESH, P_XMESH, P_YMESH, NXMESH, NYMESH, dX, dY, dKX, dKY)

!==========================================!
!DEFINE POTENTIALS(2D GRID, COMPLEX) !
!==========================================!
OPEN(UNIT=INUM, FILE='data/input/POTFUNC', ACTION='READ')
DO I=1, L, 1
    DO J=1, M, 1
    READ(INUM ,*)XJUNK, YJUNK, V_D_REAL(I,J), V_F_REAL(I, J), PSI_READ(I, J), C_CAP(I, J)
    ENDDO ; ENDDO

CLOSE(INUM)


GAMMA_FUNC= 2.D0* PI* COUPLING_W(XMESH, YMESH)**2.0D0
!V_D = CMPLX(POTENTIAL_D(XMESH, YMESH),-0.50D0*DABS(GAMMA_FUNC))
V_D = V_D_REAL+CMPLX(0.00D0,-0.50D0*DABS(GAMMA_FUNC))
V_F = CMPLX(V_F_REAL, 0.000D0)
PSI_D0_EXT = CMPLX(PSI_READ, 0.000D0)


ALLOCATE (CAP_VFUNC(L, M))
ETA = 0.004634279D0
DO I =1, L
    DO J=1, M
    CAP_VFUNC(I, J)=CAP_FUNC(XMESH(I, J), YMESH(I, J))
    ENDDO
ENDDO


C_CAP = ETA*CAP_VFUNC
!V_F= CMPLX(POTENTIAL_F(XMESH, YMESH), -1.0D0*C_CAP)
!V_F= V_F+CMPLX(0.00D0, -1.0D0*C_CAP)

DEALLOCATE (CAP_VFUNC)
DEALLOCATE (V_D_REAL)
DEALLOCATE (V_F_REAL)
DEALLOCATE (PSI_READ)

ALLOCATE (T_KE(L, M))
ALLOCATE (V11(L, M))
ALLOCATE (V22(L, M))
ALLOCATE (V12(L, M))
ALLOCATE (V21(L, M))
ALLOCATE (V_DIAG(L, M))
ALLOCATE (V_F_AUG(L, M))
ALLOCATE (PSI_XF(L, M))
ALLOCATE (PSI_XD(L, M))
ALLOCATE (FACT1(L, M))
ALLOCATE (FACT2(L, M))

!===========================================================================!
!FACT1 AND FACT2 ARE MULTIPLICATIVE FACTORS NEEDED BEFORE AND AFTER FFT     !
!CONSIDER THESE AS SOME KIND OF NORMALIZING FACTORS.!
!===========================================================================!

FACT1 = (dX / DSQRT(2.0D0 * PI)) * (dY / DSQRT(2.0D0 * PI)) *&
    (CDEXP(CMPLX(0.D0, -1.0D0) * P_XMESH(1, 1) * XMESH)) * & 
 (CDEXP(CMPLX(0.D0, -1.0D0) * P_YMESH(1, 1) * YMESH)) 


FACT2 = (CDEXP(CMPLX(0.0D0, -1.0D0)* XMESH(1, 1) *& 
   dKX * DFLOAT(NXMESH))) * &
(CDEXP(CMPLX(0.0D0, -1.0D0) * YMESH(1, 1) * & 
   dKY * DFLOAT(NYMESH)))

DEALLOCATE (NXMESH)
DEALLOCATE (NYMESH)

!================================================================!
!DEFINE MATRIX ELEMENTS OF 2X2 HAMILTONIAN (POTENTIAL PART)!
!================================================================!

V_F_AUG = V_F+ EKIN
T_KE = CDEXP(CMPLX(0.0D0, -1.0D0) * dT * HBAR *( ((P_XMESH* P_XMESH)/&
  (2.0D0 * XM_X)) + ((P_YMESH* P_YMESH)/(2.0D0 * XM_Y))))

V_DIAG = CDEXP((CMPLX(0.0D0, -1.0D0) * 0.5D0 * dT / HBAR)&
* ((V_D + V_F_AUG) / 2.0D0))
V11 = CDEXP((CMPLX(0.0D0, -1.0D0) * 0.5D0 * dT / HBAR)&
* ((V_D - V_F_AUG) / 2.0D0))

!V11 = CDCOS(0.5D0*dT*((V_D - V_F_AUG) / 2.0D0))
!     &    +  CMPLX(0.0D0, -1.0D0) * 
!     &     CDSIN(0.5D0*dT*((V_D - V_F_AUG) / 2.0D0))
V12= CMPLX(0.0D0,0.00D0)

V21 = (CMPLX(0.0D0, -1.0D0) * 0.5D0 * dT / HBAR) * &
 DSQRT(DABS(GAMMA_FUNC)/(2.D0*PI))

!     V21 = DSQRT(DABS(GAMMA_FUNC)/(2.D0*PI))
!     & * CMPLX(0.0D0, 1.0D0) * CDSIN((0.5D0*dT/HBAR)*
!     &  ((V_D-V_F_AUG)/ 2.D0))/((V_D-V_F_AUG)/ 2.D0)
     
V22 = CDEXP((CMPLX(0.0D0, 1.0D0) * 0.5D0 * dT / HBAR) &
* ((V_D - V_F_AUG) / 2.0D0))

DEALLOCATE (P_XMESH)
DEALLOCATE (P_YMESH)
DEALLOCATE (V_D)
DEALLOCATE (V_F)
DEALLOCATE (V_F_AUG)
DEALLOCATE (GAMMA_FUNC)
!================================================!
!DEFINE PSI_X AT TIME, T=0 AND NORMALIZE IT.     !
!================================================!

!PSI_XD =CMPLX(PSI_D0(XMESH, YMESH), 0.00D0) 
PSI_XD = PSI_D0_EXT 
PSI_XD = PSI_XD/DSQRT(WF_NORM(PSI_XD, X, Y))
PSI_XF = CMPLX(0.00D0, 0.000D0)
DEALLOCATE (PSI_D0_EXT)
DEALLOCATE (XMESH)
DEALLOCATE (YMESH)

!================================================!
!STORING SOME DATA IN ARRAYS AT TIME, T=0  !
!================================================!

XNORM_D(1)=WF_NORM(PSI_XD, X, Y)
XNORM_F(1)=WF_NORM(PSI_XF, X, Y)
XNORM_CAP(1)=0.000D0

ALLOCATE (TIME_ARRAY(NSTEPS))
ALLOCATE (FLUX(NSTEPS))

FLUX = 0.0D0
TIME_ARRAY = 0.0D0

FLUX(1)= 0.0000D0
TIME=0.00D0
TIME_ARRAY(1)=TIME


ALLOCATE (PSI_KF(L, M)) 
ALLOCATE (PSI_KD(L, M))
ALLOCATE (CP_PSIXD(L, M))

   !========================!
   !START OF TIME LOOP!
   !========================!

DO I= 2,NSTEPS,1  

    CP_PSIXD = PSI_XD
    PSI_XD= V11*PSI_XD+V12*PSI_XF
    PSI_XF= V21*CP_PSIXD+V22*PSI_XF

    PSI_XD = V_DIAG * PSI_XD
    PSI_XF = V_DIAG * PSI_XF

    PSI_XD=FACT1* PSI_XD
    PSI_XF=FACT1* PSI_XF
     
    CALL FFT2D(PSI_XD, 'F', PSI_KD)
    CALL FFT2D(PSI_XF, 'F', PSI_KF)

    PSI_KD = PSI_KD * FACT2
    PSI_KF = PSI_KF * FACT2

    PSI_KD = PSI_KD* T_KE
    PSI_KF = PSI_KF* T_KE

    PSI_KD = PSI_KD/FACT2
    PSI_KF = PSI_KF/FACT2

    CALL FFT2D(PSI_KD, 'B', PSI_XD)
    CALL FFT2D(PSI_KF, 'B', PSI_XF)
     
    PSI_XD =PSI_XD/FACT1
    PSI_XF =PSI_XF/FACT1

    CP_PSIXD = PSI_XD
    PSI_XD = V11 * PSI_XD + V12 * PSI_XF
    PSI_XF = V21 * CP_PSIXD + V22 * PSI_XF
    PSI_XD = V_DIAG * PSI_XD
    PSI_XF = V_DIAG * PSI_XF

    TIME = TIME+1.0D0 * dT

    ALLOCATE (PSI_MOD_XD(L, M))
    ALLOCATE (PSI_MOD_XF(L, M))

    PSI_MOD_XD = FACT1*PSI_XD
    PSI_MOD_XF = FACT1*PSI_XF

    CALL FFT2D(PSI_MOD_XD, 'F', PSI_KD)
    CALL FFT2D(PSI_MOD_XF, 'F', PSI_KF)

    DEALLOCATE (PSI_MOD_XD)
    DEALLOCATE (PSI_MOD_XF)

    PSI_KD = PSI_KD * FACT2
    PSI_KF = PSI_KF * FACT2

   !=======================================================!
   !THOUGH PSI_K VALUES ARE NOT NEEDED ANYWHERE IN THE     ! 
   !PROGRAM, WE STILL CALCULATE IT FOR FUTURE PURPOSE!
   !=======================================================!

    XINST_FLUX = XINTEGRATE2D (X, Y, (C_CAP* REAL(PSI_XF*CONJG(PSI_XF))),'TR')     

     
    TIME_ARRAY(I)=TIME
    FLUX(I)=XINST_FLUX

    XNORM_D(I)=WF_NORM(PSI_XD, X, Y)
    XNORM_F(I)=WF_NORM(PSI_XF, X, Y)

    CALL XINTGR1D(TIME_ARRAY(1:I), FLUX(1:I),  'TR', SIZE(TIME_ARRAY(1:I)), XVAL)

    XNORM_CAP(I)=2.0D0*XVAL

ENDDO

   !========================!
   !END OF TIME LOOP  !
   !========================!


DEALLOCATE (T_KE)
DEALLOCATE (V11)
DEALLOCATE (V22)
DEALLOCATE (V12)
DEALLOCATE (V21)
DEALLOCATE (V_DIAG)
DEALLOCATE (C_CAP)
DEALLOCATE (FACT1)
DEALLOCATE (FACT2)
DEALLOCATE (CP_PSIXD)

!====================!
!CALCULATE SIGMA     !
!====================!
!V_D = V_D - CMPLX(0.000D0, -0.5000D0*DABS(GAMMA_FUNC))
!V_F= V_F - CMPLX(0.00D0, -1.0D0*C_CAP)

CALL XINTGR1D(TIME_ARRAY, FLUX,  'TR', NSTEPS, VAL)

DEALLOCATE (TIME_ARRAY)
DEALLOCATE (FLUX)
     
SIGMA = WF_NORM(PSI_XF, X, Y)+2.0D0*VAL

DEALLOCATE (PSI_KF) 
DEALLOCATE (PSI_KD)
DEALLOCATE (PSI_XF)
DEALLOCATE (PSI_XD)
DEALLOCATE (X)
DEALLOCATE (Y)

END SUBROUTINE GEN_SIGMA


!====================================================================================
!====================================================================================   
!FUNCTION POTENTIAL_D, POTENTIAL_F, COUPLING_W CALCULATES THE METASTABLE STATE, FINAL
! STATE AND THE COUPLING W ELEMENTS BY TAKING UP XMESH AND YMESH (2D ARRAYS)
!RESULT: THE 2D ARRAYS OF CORRESPONDING POTENTIALS.
! NEED TO CREATE INTERFACE DIRECTIVE IN THE PROGRAM/SUBROUTINE IF YOU WANT TO USE 
! THEM ANYWHERE.
!FUNCTION PSI_D0: CREATES THE INITIAL WAVE-FUNCTION NEEDED IN META-STABLE STATE AT
! TIME=0.
!====================================================================================
!
FUNCTION POTENTIAL_D(XMESH, YMESH) RESULT(Z)
USE CONST
IMPLICIT REAL*8(A-H,O-Z)
INTENT(IN) :: XMESH, YMESH
DIMENSION XMESH(L, M), YMESH(L, M), Z(L, M)

DE_RES = 0.0650D0
X0_RES = 2.5D0
A_RES = 0.65D0
Y0_RES = 2.0D0
SHIFT= 0.30D0

Z= SHIFT + DE_RES * (1.0D0 - DEXP(-A_RES * &
(XMESH - X0_RES))) ** 2.0D0 &
     + DE_RES * (1 - DEXP(-A_RES * (YMESH - Y0_RES)))** 2.0D0

END FUNCTION POTENTIAL_D

!
FUNCTION POTENTIAL_F(XMESH, YMESH) RESULT(Z)
USE CONST
IMPLICIT REAL*8(A-H,O-Z)
INTENT(IN) :: XMESH, YMESH
DIMENSION XMESH(L, M), YMESH(L, M), Z(L, M)

DE_TAR = 0.0650D0
X0_TAR = 5.0D0
A_TAR = 0.15D0
Y0_TAR = 4.5D0

Z = 0.30D0* DEXP(-0.05D0* (XMESH* YMESH))

!Z= DE_TAR * (1.0D0 - DEXP(-A_TAR * (XMESH - X0_TAR))) ** 2.0D0+
!     &     DE_TAR * (1.0D0 - DEXP(-A_TAR * (YMESH - Y0_TAR)))** 2.0D0

END FUNCTION POTENTIAL_F

!
FUNCTION COUPLING_W(XMESH, YMESH) RESULT(Z)
USE CONST
IMPLICIT REAL*8(A-H,O-Z)
INTENT(IN) :: XMESH, YMESH
DIMENSION XMESH(L, M), YMESH(L, M), Z(L, M)

Z=0.009D0+0.0D0*XMESH*YMESH
END FUNCTION COUPLING_W
 
! 
FUNCTION PSI_D0(XMESH,YMESH) RESULT(Z)
USE CONST
IMPLICIT REAL*8(A-H,O-Z)
INTENT(IN) :: XMESH, YMESH
DIMENSION XMESH(L, M), YMESH(L, M), Z(L, M)

X0 = 2.50D0
Y0 = 6.0D0
F_CONST = 0.00585D0

Z =(((DSQRT( F_CONST* XM_X)) / (PI))** 0.25D0) * &
     DEXP(-((XMESH- X0) ** 2.0D0 &
   + (YMESH - Y0) ** 2.0D0) * (DSQRT(F_CONST * XM_Y)) / (2.D0))
     
END FUNCTION PSI_D0
 
!====================================================================================
!FUNCTION: CAP_FUNC CALCULATES THE ABSORBING CAP AT THE GRID END
!TAKES UP SINGLE X AND Y VALUES (NOT ARRAYS) AND CALCULATES CAP AT THAT COORDINATE. 
!====================================================================================
FUNCTION CAP_FUNC(X, Y)
USE CONST
IMPLICIT REAL*8(A-H,O-Z)
REAL*8, INTENT(IN):: X, Y
X_BARRIER = 7.5D0
Y_BARRIER = 45.0D0

IF ((X .GT. X_BARRIER) .AND. (Y .LT. Y_BARRIER)) THEN
    Z= ((ABS(X - X_BARRIER))**3.0D0)
ELSE IF ((Y .GT. Y_BARRIER) .AND. (X .LT. X_BARRIER)) THEN
    Z= ((ABS(Y - Y_BARRIER))**3.0D0)*10.0D-4
ELSE IF ((X .GT. X_BARRIER) .AND. (Y .GT. Y_BARRIER)) THEN
    Z= ((ABS(X - X_BARRIER))**3.0D0) + ((ABS(Y - Y_BARRIER))**3.0D0)*10.0D-4
ELSE
    Z= 0.0D0
ENDIF
CAP_FUNC = Z
END FUNCTION CAP_FUNC

!====================================================================================
!FUNCTION: WF_NORM CALCULATES NORM GIVEN F IS A 2D FUNCTION IN X AND Y COORDINATE
!GIVES BACK A REAL VALUE OF INTEGRATION VIA TRAPEZOIDAL RULE
!====================================================================================
FUNCTION WF_NORM(F, X, Y)
USE CONST
IMPLICIT REAL*8(A-H,O-Z)
EXTERNAL :: XINTEGRATE2D
COMPLEX, INTENT(IN) :: F
REAL*8, INTENT(IN) :: X, Y
DIMENSION Z(L, M)
DIMENSION F(L, M)
DIMENSION X(L), Y(M)
Z = REAL(F*CONJG(F))
WF_NORM= XINTEGRATE2D (X, Y, Z, 'TR')
END FUNCTION WF_NORM

!====================================================================================
!NOT NEEDED RIGHT NOW AS THIS PART IS ALREADY INCLUDED IN GEN_SIGMA
!
!SUBROUTINE: PROPAGATE- PROPAGATES THE PSI_XF AND PSI_XD WITH TIME FOR NSTEPS
!TIME STEPS IN TOTAL. CALLING THIS SUBROUTINE YIELDS MODIFIED PSI_XD AND PSI_XF
!AT EACH SUBSEQUENT TIME STEPS, NAMELY PSI_XD AND PSI_XF
!====================================================================================

SUBROUTINE PROPAGATE(T_KE, V11, V12, V21, V22, V_DIAG, PSI_XD, PSI_XF, TIME, C_CAP, X, Y, FACT1, FACT2,&
  PSI_KD, PSI_KF, XINST_FLUX)
     
USE CONST

IMPLICIT REAL*8(A-H,O-Z)
EXTERNAL :: XINTEGRATE2D
COMPLEX, INTENT(IN) :: T_KE, V11, V12, V21, V22, V_DIAG
COMPLEX, INTENT(INOUT) :: PSI_XD, PSI_XF
REAL*8, INTENT(INOUT) :: TIME
REAL*8, INTENT(IN) :: C_CAP
REAL*8, INTENT(IN) :: X, Y
COMPLEX, INTENT(IN) :: FACT1, FACT2

COMPLEX, INTENT(OUT) :: PSI_KF, PSI_KD
REAL*8, INTENT(OUT) :: XINST_FLUX

DIMENSION PSI_KD(L, M), PSI_KF(L, M)
DIMENSION PSI_XD(L, M), PSI_XF(L, M)

DIMENSION T_KE(L, M), V11(L, M), V12(L, M), V21(L, M)
DIMENSION V22(L, M), V_DIAG(L, M)
DIMENSION FACT1(L, M), FACT2(L, M), C_CAP(L, M)

!REAL(8), ALLOCATABLE :: X(:), Y(:), C_CAP(:, :)
!COMPLEX, ALLOCATABLE :: FACT1(:, :), FACT2(:, :)

COMPLEX, ALLOCATABLE :: PSI_MOD_XD(:, :)
COMPLEX, ALLOCATABLE :: PSI_MOD_XF(:, :)

COMPLEX CP_PSIXD(L, M)



!ALLOCATE (FACT1(L, M))
!ALLOCATE (FACT2(L, M))

CP_PSIXD = PSI_XD
PSI_XD= V11*PSI_XD+V12*PSI_XF
PSI_XF= V21*CP_PSIXD+V22*PSI_XF

PSI_XD = V_DIAG * PSI_XD
PSI_XF = V_DIAG * PSI_XF

PSI_XD=FACT1* PSI_XD
PSI_XF=FACT1*PSI_XF
     
CALL FFT2D(PSI_XD, 'F', PSI_KD)
CALL FFT2D(PSI_XF, 'F', PSI_KF)

PSI_KD = PSI_KD * FACT2
PSI_KF = PSI_KF * FACT2

PSI_KD = PSI_KD* T_KE
PSI_KF = PSI_KF* T_KE

PSI_KD = PSI_KD/FACT2
PSI_KF = PSI_KF/FACT2

CALL FFT2D(PSI_KD, 'B', PSI_XD)
CALL FFT2D(PSI_KF, 'B', PSI_XF)
     
PSI_XD =PSI_XD/FACT1
PSI_XF =PSI_XF/FACT1

CP_PSIXD = PSI_XD
PSI_XD = V11 * PSI_XD + V12 * PSI_XF
PSI_XF = V21 * CP_PSIXD + V22 * PSI_XF
PSI_XD = V_DIAG * PSI_XD
PSI_XF = V_DIAG * PSI_XF

TIME = TIME+1.0D0 * dT

ALLOCATE (PSI_MOD_XD(L, M))
ALLOCATE (PSI_MOD_XF(L, M))

PSI_MOD_XD = FACT1*PSI_XD
PSI_MOD_XF = FACT1*PSI_XF

CALL FFT2D(PSI_MOD_XD, 'F', PSI_KD)
CALL FFT2D(PSI_MOD_XF, 'F', PSI_KF)

DEALLOCATE (PSI_MOD_XD)
DEALLOCATE (PSI_MOD_XF)

PSI_KD = PSI_KD * FACT2
PSI_KF = PSI_KF * FACT2

!DEALLOCATE (FACT1)
!DEALLOCATE (FACT2)


!ALLOCATE (X(L))
!ALLOCATE (Y(M))
!ALLOCATE (C_CAP(L, M))

XINST_FLUX = XINTEGRATE2D (X, Y, (C_CAP* REAL(PSI_XF*CONJG(PSI_XF))),'TR')     

!DEALLOCATE (X)
!DEALLOCATE (Y)
!DEALLOCATE (C_CAP)

END SUBROUTINE PROPAGATE   


